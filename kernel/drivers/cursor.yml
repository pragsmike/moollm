# Cursor Driver
# Adapts MOOLLM constitution to Cursor IDE

driver:
  name: "cursor"
  tier: 4
  description: "Cursor IDE with Agent mode"
  hot_cold_mode: advisory  # Files are suggestions, not commands

# How to detect you're running on Cursor
# (Used by bootstrap introspection protocol)
detection:
  system_prompt_indicators:
    - "You operate in Cursor"
    - "Cursor IDE"
    - "You are an AI coding assistant, powered by Claude"
    
  tool_indicators:
    required:
      - codebase_search    # Cursor's semantic search
      - search_replace     # Cursor's file editing
      - read_file          # File reading
      - write              # File writing
    strong_signals:
      - mcp_cursor-ide-browser_*   # Cursor's browser integration
      - grep               # Cursor's ripgrep wrapper
      - glob_file_search   # Cursor's file finder
      
  environment_indicators:
    - "workspace_path in user_info"
    - "terminals folder path"
    
  confidence: |
    If you see codebase_search + search_replace + system prompt mentions Cursor:
    → 99% confidence this is Cursor
    → Load this driver
    → Use advisory mode for hot/cold files

# What Cursor can do
capabilities:
  file_read: true
  file_write: true
  file_search: true
  semantic_search: true
  terminal: true
  sandboxed_terminal: true
  custom_tools: false      # Can't add our own tools
  mcp: true               # Cursor supports MCP
  why_parameter: false     # Can't modify built-in tool schemas
  append_only_enforcement: false
  background_indexing: true

# Path conventions (relative to workspace)
paths:
  # Cursor works in workspace root, so we use a subdirectory
  session_root: ".moollm/"
  output_sink: ".moollm/output.md"
  session_log: ".moollm/session-log.md"
  working_set: ".moollm/working-set.yml"
  hot_cache: ".moollm/hot.yml"
  cold_cache: ".moollm/cold.yml"
  summaries: ".moollm/summaries/"
  artifacts: ".moollm/artifacts/"

# Map abstract operations to Cursor tools
tools:
  # File operations
  read_file:
    tool: "read_file"
    notes: "Cursor's built-in file reader"
    
  write_file:
    tool: "write"
    notes: "Overwrites entire file"
    prefer: "search_replace for edits"
    
  edit_file:
    tool: "search_replace"
    notes: "Preferred for modifications"
    
  list_dir:
    tool: "list_dir"
    
  delete_file:
    tool: "delete_file"
    notes: "Use sparingly"

  # Search operations
  semantic_search:
    tool: "codebase_search"
    notes: "Semantic search by meaning"
    
  text_search:
    tool: "grep"
    notes: "Exact text/regex search"
    
  file_search:
    tool: "glob_file_search"
    notes: "Find files by pattern"

  # Execution
  terminal:
    tool: "run_terminal_cmd"
    notes: "Sandboxed by default"
    permissions: ["network", "git_write", "all"]

  # No direct equivalents - use workarounds
  append_file:
    tool: null
    workaround: "read_file + write with appended content"
    
  vector_search:
    tool: "codebase_search"
    notes: "Cursor's semantic search serves this purpose"

# Adaptations for unsupported features
adaptations:
  why_parameter:
    supported: false
    fallback: "inline"
    instruction: |
      Since Cursor tools don't support a 'why' parameter, document intent
      in your response BEFORE making tool calls:
      
      "I'm reading package.json to check dependencies because..."
      [tool call]
      
  append_only:
    supported: false
    fallback: "convention"
    instruction: |
      Cursor can't enforce append-only at the tool level.
      TREAT output.md and session-log.md AS append-only by convention:
      - Always read first
      - Append to existing content
      - Never overwrite
      
  event_logging:
    supported: false
    fallback: "session_log_markdown"
    instruction: |
      Instead of events.jsonl, use session-log.md in markdown format:
      
      ## [timestamp] Action
      - Tool: tool_name
      - Intent: why you did it
      - Result: brief outcome

  working_set:
    supported: "manual"
    instruction: |
      Cursor doesn't read working-set.yml automatically.
      Maintain it as a reference for yourself:
      - Update when focus changes
      - Consult when context is unclear
      - Helps with memory across turns

# CRITICAL: How hot/cold/working-set files work on Cursor
memory_management:
  mode: advisory
  
  explanation: |
    On Cursor, hot.yml, cold.yml, and working-set.yml are ADVISORY, not magic.
    
    Cursor manages context automatically via:
    - Built-in vector search (codebase_search)
    - Automatic file indexing
    - Its own attention/relevance algorithms
    
    These files serve different purposes on Cursor:
    
  hot_yml:
    purpose: "Suggestion of what's important"
    behavior: |
      - NOT automatically loaded by Cursor
      - Serves as documentation of what SHOULD be prioritized
      - You can consult it to remember what was deemed important
      - Can be generated IN REVERSE: after a session, update to reflect
        what was actually frequently accessed
        
  cold_yml:
    purpose: "Documentation of what was deprioritized"
    behavior: |
      - NOT automatically evicted by Cursor
      - Serves as breadcrumbs for why things were forgotten
      - Helps answer "why doesn't it remember X?"
      - Useful for session archaeology
      
  working_set_yml:
    purpose: "Snapshot of current focus"
    behavior: |
      - NOT read by Cursor to assemble prompts
      - Can be maintained as self-documentation
      - Can be GENERATED by you to reflect what you're focused on
      - Helps with continuity across conversations
      
  reverse_generation: |
    On Cursor, these files can work IN REVERSE:
    Instead of directing the orchestrator, they can be GENERATED
    to reflect what Cursor's attention system is actually focused on.
    
    This provides the same debugging benefit:
    "What is in context?" → check working-set.yml
    "What was forgotten?" → check cold.yml
    "What should be prioritized?" → check hot.yml
    
    The files become documentation rather than commands,
    but the mental model and debugging story remain the same.

# Cursor-specific features to leverage
cursor_features:
  # Use Cursor's strengths
  leverage:
    - "codebase_search for semantic queries"
    - "Background indexing for fast search"
    - "Multi-file editing with search_replace"
    - "Terminal with permission system"
    - "MCP for external integrations"
    
  # Cursor limitations to work around
  limitations:
    - "No custom tool schemas"
    - "No enforced append-only"
    - "No structured event logging"
    - "Context window managed by Cursor"

# Boot instructions for Cursor
boot:
  check_exists:
    - ".moollm/"
  create_if_missing:
    - ".moollm/output.md"
    - ".moollm/session-log.md"
    - ".moollm/working-set.yml"
  initial_log: |
    # MOOLLM Session Log
    Driver: cursor
    Started: [timestamp]
    
    ---

# Example session-log.md entry format
log_format: |
  ## [2025-12-30T12:30:00Z] Read Configuration
  - **Intent**: Check current settings before making changes
  - **Tool**: read_file
  - **Target**: package.json
  - **Outcome**: Found dependencies list
  
  ---
