According to a document snapshot you provided on **January 14, 2026**, here are recommendations framed as **“how to implement Brain2 (Jones Second Brain) *inside* MOOLLM”** with **minimal changes to MOOLLM** (i.e., mostly *new skills + conventions*, not kernel surgery).

---

## Brain2 as a MOOLLM microworld

### Guiding constraints (MOOLLM-native)

* **Filesystem is the world; files are objects; LLM is `eval()`**.
* **Files don’t move; state changes via properties (e.g., `location:`)** to keep history clean and everything inspectable/editable.
* **YAML Jazz is semantic**: comments are meaning, not decoration; don’t build tooling that strips or round-trips comments destructively.
* **Kernel stays boring**: use existing protocols (context assembly, event logging, tool-calling `why`, self-healing) and implement Brain2 in “userland skills.”

---

## Implement the 8 Jones building blocks using MOOLLM primitives

### 1) Dropbox → **`/world/inbox/` capture objects**

Implement capture as *one file per thought* (or append-only capture stream that is then split), preserving the raw text exactly.

* Jones’ core requirement: capture is low-friction; everything else is automation.

**MOOLLM fit:** creating a new file is just “spawn an object.”

---

### 2) Sorter → a **MOOLLM skill with a CARD interface + patch-only executor**

Create a `skills/brain2-sorter/` skill that:

* reads an inbox object
* returns a **minimal patch plan** (unified diff) to update/instantiate the right state objects
* never “freewrites” the world; it proposes deterministic edits

MOOLLM already pushes “skills are programs” and tool calls require explicit intent (`why`).

**Key design point:** The Sorter should *prefer adding/updating properties* (e.g., `kind`, `status`, `location`, links) over moving files, consistent with “files don’t move.”

---

### 3) Form → **YAML Jazz objects as the canonical state format**

Represent each knowledge object (person/project/idea/admin) as YAML (optionally with paired Markdown narrative), but do it in a way that fully respects MOOLLM’s **“comments are semantic”** invariant.

Practical implementation rules:

* edits are **minimal diffs** (patches), not reserialization
* “jazz first, standards later” (let structure emerge, then crystallize)

---

### 4) Filing cabinet → **directory identity + naming + views (not a DB, not moves)**

Jones wants a memory store that’s writable by automation and readable by humans, with “filters and views.”

In MOOLLM, you get that by combining:

* **Directory identity:** `thing/thing.yml` is the object definition; `thing/thing.md` can hold narrative.
* **Big-endian naming:** names cluster related files so the filesystem *is* the semantic network.
* **Views as separate objects:** create `views/active-projects.yml`, `views/needs-review.yml`, etc., that list references (paths/IDs). This mirrors Jones’ “views” without requiring Notion.

You can still keep your conceptual tree (`people/`, `projects/`, `ideas/`), but the “routing” action is:

* update `kind:` and `location:` (and link fields)
* update relevant view/index files
  —not physically moving the capture file.

---

### 5) Receipt → **append-only event log entries**

Jones’ trust mechanism is explicit: every capture gets logged with original text, where it was filed, the name, and confidence—because visibility builds trust.

In MOOLLM, implement Receipt as:

* append-only `session-log.md` / `event-log.md` entries (per kernel conventions)
* include: input path, proposed patches applied, confidence, and the Sorter’s “why” reasoning (short)
  This stays aligned with: “output/session logs are append-only,” and “every tool call has `why`.”

---

### 6) Bouncer → **`status: needs-review` + clarification request**

Jones’ bouncer: if confidence is below a threshold (he gives “let’s say .6”), don’t file; mark needs-review and ask the user to clarify/repost with a prefix.

MOOLLM implementation:

* set `status: needs-review`
* set `location: needs-review` (property change, not a move)
* append a receipt entry + generate a telepresence message that asks the clarifying question

Keep the threshold configurable in YAML (and *jazzable* with comments describing why).

---

### 7) Tap on shoulder → **K-line digests (scheduled + on-demand)**

Jones: daily Slack DM digest (and weekly) generated by automation; includes “top 3 actions,” “one stuck thing,” “one small win,” sized to a phone screen.

MOOLLM’s native mechanism for “invoke a behavior constellation” is **K-lines** (“names that activate constellations”).

Implement:

* `DAILY-DIGEST` and `WEEKLY-REVIEW` as K-line skills that:

  * read `views/active-projects.yml`, `views/follow-ups.yml`, `views/needs-review.yml`
  * synthesize a short digest
* schedule can be external (cron/systemd) calling the same K-line; MOOLLM doesn’t require the scheduler to live in-kernel.

---

### 8) Fix button → **edit the text; next tick re-evaluates**

This is already MOOLLM-native: “Everything is inspectable. Everything is editable.”

Implementation:

* user edits the YAML/Markdown object directly (preserving Jazz comments)
* next run (“tick”) recomputes indexes/views, and logs what changed (minimal diffs)

---

## Make it robust and low-friction with existing kernel protocols

### Use `working-set.yml` to keep Brain2’s “active memory” small and relevant

MOOLLM’s context assembly protocol gives you the equivalent of “active databases/views” by controlling what’s loaded into context via a working-set manifest with priorities and truncation strategies.

For Brain2, your working set typically includes:

* constitution (always)
* Sorter skill + its schemas
* today’s active views (active projects, follow-ups, needs-review)
* recent receipt log tail (truncate “start” to keep recent)

---

## Minimal changes to MOOLLM (what you *don’t* need to change)

* No kernel modifications required: Brain2 lives as **skills + conventions**, using kernel protocols for tools/context/logging.
* No need to weaken YAML Jazz: it’s already a stated invariant (“YAML comments are semantic”).
* No need to introduce “file moves” as state transitions: MOOLLM already provides a better primitive (`location:`).

If you want, next I can sketch a concrete **directory layout + the minimal set of Brain2 skills/K-lines** (names, files, and what each CARD would input/output) that fits MOOLLM’s naming protocol and “about-not-inside” conventions.

