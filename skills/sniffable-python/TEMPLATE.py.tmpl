#!/usr/bin/env python3
"""{{name}}: {{purpose}}

{{description}}

Usage:
    python {{name}}.py command [options]
    
Examples:
    python {{name}}.py --help
    {{examples}}
"""

import argparse
from pathlib import Path
from typing import Optional
import yaml

# Configuration
DEFAULT_VALUE = "{{default_value}}"  # {{default_explanation}}
VALID_OPTIONS = {{valid_options}}    # {{options_explanation}}

def main():
    """Main entry point â€” CLI structure only, no implementation.
    
    The entire command tree is visible here. Implementation is below.
    """
    parser = argparse.ArgumentParser(
        description=__doc__.split('\n')[0],
        formatter_class=argparse.RawDescriptionHelpFormatter
    )
    parser.add_argument("--version", action="version", version="0.1.0")
    
    subparsers = parser.add_subparsers(dest="command", required=True)
    
{{#commands}}
    # {{command_name}} command
    {{command_name}}_parser = subparsers.add_parser(
        "{{command_name}}", 
        help="{{command_description}}"
    )
    {{command_name}}_parser.add_argument(
        "{{argument_name}}", 
        help="{{argument_description}}"
    )
    {{command_name}}_parser.add_argument(
        "--verbose", "-v", 
        action="store_true",
        help="Show detailed output"
    )
{{/commands}}
    
    args = parser.parse_args()
    _dispatch(args)

# Implementation (LLM only reads past here if modifying behavior)

def _dispatch(args):
    """Route to appropriate handler based on command."""
{{#commands}}
    if args.command == "{{command_name}}":
        _{{command_name}}_impl(args.{{argument_name}}, args.verbose)
{{/commands}}

{{#commands}}
def _{{command_name}}_impl({{argument_name}}: str, verbose: bool) -> None:
    """Internal: Execute {{command_name}} command."""
    if verbose:
        print(f"Running {{command_name}} with {{{argument_name}}}...")
    
    # TODO: Implement {{command_name}} logic
    print(f"{{command_name}} completed.")

{{/commands}}

# === MAIN ===
if __name__ == "__main__":
    main()
