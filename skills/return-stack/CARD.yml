# CARD.yml ‚Äî Return Stack
#
# Navigation history as first-class continuation.
# "Remember where you came from."
#
# Inspired by Self's dynamic deoptimization ‚Äî reconstruct
# what the stack WOULD have been, even without explicit tracking.

card:
  id: return-stack
  name: "Return Stack"
  type: [skill, navigation, memory, debugging]
  emoji: üîô
  rarity: common
  
  description: |
    Navigation history like browser back/forward. Save positions,
    return to them. The stack is a first-class object you can
    manipulate.
    
    PLUS: Self-inspired dynamic deoptimization (aka pessimization) ‚Äî 
    reconstruct causal traces after the fact for debugging, even when 
    no explicit stack was maintained during execution.

tools:
  required: [read_file, write_file]
tier: 1

# DYNAMIC DEOPTIMIZATION (Self-inspired)

dynamic-deoptimization:
  inspiration: |
    Self (the language) aggressively inlines method calls for performance,
    eliminating the return stack entirely. But when you hit a breakpoint
    or error, it DYNAMICALLY DEOPTIMIZES ‚Äî reconstructing what the stack
    WOULD have looked like if inlining hadn't happened.
    
    This is perfect for debugging: you get performance AND debuggability.
    
  moollm-application: |
    MOOLLM doesn't maintain an explicit call stack during normal operation.
    Methods invoke methods, advertisements trigger actions, effects cascade.
    
    But at any point ‚Äî error, breakpoint, or curiosity ‚Äî MOOLLM can
    RECONSTRUCT the causal trace:
    
    "How did we get here? What caused what?"
    
  reconstructed-trace:
    description: |
      After-the-fact generation of a causal stack showing:
      - Which advertisement was triggered
      - What method was invoked
      - What parameters were passed
      - What effects cascaded
      - What state changed
      
    example: |
      üîç CAUSAL TRACE (reconstructed):
      
      ‚îå‚îÄ [1] User: "TAKE the key"
      ‚îÇ
      ‚îú‚îÄ [2] Advertisement matched: pub/key.yml ‚Üí TAKE
      ‚îÇ      score: 95, condition: "player wants to pick up object"
      ‚îÇ
      ‚îú‚îÄ [3] Method invoked: adventure/TAKE
      ‚îÇ      parameters: { item: "key", actor: "don-hopkins" }
      ‚îÇ
      ‚îú‚îÄ [4] Effect: key.location ‚Üê "don-hopkins/inventory"
      ‚îÇ      previous: "pub/bar-counter.yml"
      ‚îÇ
      ‚îú‚îÄ [5] Side effect: pub/bar-counter.yml updated
      ‚îÇ      removed: "key" from contents
      ‚îÇ
      ‚îî‚îÄ [6] Narrative generated: "You pick up the brass key..."
      
    debugging-use: |
      When something goes wrong, RECONSTRUCT TRACE shows exactly
      what happened:
      
      "Why does the key have location: null?"
      
      ‚Üí Trace reconstruction reveals step [4] failed because
        inventory file didn't exist yet.
        
  vs-explicit-stack: |
    EXPLICIT STACK (traditional):
      - Maintained during execution
      - Overhead for every call
      - Always available
      
    DYNAMIC DEOPTIMIZATION (Self/MOOLLM):
      - No overhead during normal execution
      - Reconstructed on demand
      - "What WOULD the stack have been?"
      - Perfect for debugging without runtime cost

methods:
  PUSH:
    description: "Save current position"
    parameters: { label: "Optional bookmark name" }
    output: state-change
    invoked-by: [system on navigation, player]
    
  POP:
    description: "Return to previous position"
    parameters: {}
    output: chat + state-change
    invoked-by: [player]
    
  BACK:
    description: "Go back N steps"
    parameters: { steps: "How many" }
    output: chat + state-change
    invoked-by: [player]
    
  HISTORY:
    description: "Show navigation history"
    parameters: { limit: "How many to show" }
    output: chat
    invoked-by: [player]
    
  GOTO:
    description: "Jump to bookmarked position"
    parameters: { label: "Bookmark name" }
    output: chat + state-change
    invoked-by: [player]
    
  # Dynamic deoptimization methods
  
  TRACE:
    description: "Reconstruct causal trace for how we got to current state"
    parameters:
      target: "What to trace (file, state change, error)"
      depth: "How far back to trace (default: full)"
    output: chat (formatted trace)
    effect: "Analyze history to reconstruct cause/effect chain"
    invoked-by: [player, debugger]
    
  WHY:
    description: "Ask why something has its current value"
    parameters:
      what: "The thing to explain (file path, field, state)"
    output: chat (causal explanation)
    effect: "Trace backwards to find cause"
    invoked-by: [player]
    
  BLAME:
    description: "Find what action/method caused a particular change"
    parameters:
      change: "The change to investigate"
    output: chat (responsible action)
    effect: "Git-blame style attribution for state changes"
    invoked-by: [player, debugger]

state:
  stack:
    entries: { type: array, description: "Stack of positions" }
    bookmarks: { type: object, description: "Named positions" }
  trace-cache:
    recent-actions: { type: array, description: "Recent actions for reconstruction" }
    state-snapshots: { type: array, description: "Periodic snapshots for diffing" }

advertisements:
  TRACK-NAVIGATION:
    score: 85
    condition: "Exploring, want to backtrack"
  BOOKMARK-POSITION:
    score: 80
    condition: "Want to remember this spot"
  RECONSTRUCT-TRACE:
    score: 95
    condition: "Debugging, need to understand what happened"
  EXPLAIN-STATE:
    score: 90
    condition: "Confused about current state, asking 'why'"

see-also:
  - skills/action-queue   # What actions were queued
  - skills/room           # Spatial navigation
  - skills/memory-palace  # Organized memory
  - skills/debugging      # Full debugging skill
  - skills/prototype      # Self-style inheritance
  - skills/session-log    # Raw history for reconstruction

credits:
  inspiration:
    - name: "Dave Ungar & Self Team"
      contribution: "Dynamic deoptimization ‚Äî reconstruct stack for debugging without runtime overhead"
      link: "https://bibliography.selflanguage.org/"
    - name: "Urs H√∂lzle"
      contribution: "Adaptive optimization and deoptimization in Self"
  related:
    - "Browser back/forward history"
    - "Git blame ‚Äî attribution for changes"
    - "Stack traces in debuggers"
